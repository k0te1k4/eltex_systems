Использованные материалы
- [[Управление динамической памятью]]
- [[Отладчик(gdb)]]
- [[Study/Eltex/C/Указатели]]

Динамический анализатор. Анализирует программу в момент выполнения.
Показывает где именно в коде ошибка только если программа использует библиотеки, уже собранные с [[Отладчик(gdb)#Отладочная информация|отладкой]] в системе. Без отладки он покажет только наличие ошибки, но не покажет её расположение.

# Первоначальная настройка
Исходя из написанного выше можно сделать вывод, что для правильной работы с ним, программа должна быть скомпилирована с [[Отладчик(gdb)#Отладочная информация|отладкой]].
Запуск программы с valgrind:
`$ valgrind --leak-check=full ./program`
# Поиск ошибок

## Переопределение памяти
После запуска программы получаем примерно такой вывод:
![[Pasted image 20250925005833.png]]
Здесь выделена строка, которая показывает, что в 20 строке функции main файла mallopt_test.c произошла утечка 1000 байт памяти.

**Что именно нашел valgrind:**
20 и 21 строки исходной программы выглядят так:
![[Pasted image 20250925010118.png|300]]
Здесь видно, что 1000 байт мы потеряем, т.к. одному и тому же указателю присваиваем память два раза.
Но важно не это, а то, что valgrind указал ровно на 20 строку, а ведь именно в ней и выделяются 1000 байт, которые потом "утекут".

## Выход за границы **динамического** массива

**Valgrind НЕ МОЖЕТ НАЙТИ ОШИБКИ ВЫХОДА ЗА ГРАНИЦЫ СТАТИЧЕСКОГО МАССИВА!**

![[Pasted image 20250925010819.png]]
Выделена строка, указывающая, что в 22 строке функции main файла mallopt_test.c была некорректная запись **4 байт**.

**Что именно нашел valgrind:**
![[Pasted image 20250925011046.png|300]]
Здесь видно, что выделили 1000 байт, а обратились к 1001 элементу.
При этом p является **указателем на int**. 
Поэтому valgrind написал, что было некорректно выделено именно 4 байта.
Если бы p был указателем на char, valgrind бы написал, что неверно выделен 1 байт итп.

## Двойное высвобождение

В отличие от предыдущих ошибок, о двойном высвобождении можно узнать просто запустив программу. О нём сообщит glibc. Но где конкретно оно происходит без valgrind узнать не получится.

![[Pasted image 20250925011933.png]]
Отсюда видно(снизу вверх):
1. Память выделена в 20 строке
2. Первое высвобождение в 30 строке
3. Второе(неверное) высвобождение в 33 строке

**Что именно нашел valgrind:**
Исходный код программы:
![[Pasted image 20250925012205.png|400]]
1. Выделили память в 20 строке
2. Затем освободили p в 30
3. И ещё раз освободили p в 33
То есть valgrind нашёл эту ошибку и указал в каких именно строках проблема


# Valgrind + GDB
## Запуск
Посмотреть все флаги, связанные с gdb можно, если ввести просто
`valgrind <TAB>`
Чтобы запустить Valgrind с GDB:
`valgrind --leak-check=full --vgdb=full --vgdb-error=1 ./program`

После такого запуска и нахождения ошибки, valgrind будет ожидать подключения gdb:
![[Pasted image 20250925013324.png]]
Важно учитывать, что valgrind будет останавливать программу не при всех ошибках. Например при выходе за границу или двойном высвобождении он остановит и будет ждать gdb, а при утечке памяти продолжит выполнение.
## Подключение через gdb
Чтобы подключиться через gdb, нужно ввести команду:
`target remote | vgdb`

После чего в gdb мы зайдем в функцию, которая вызвала ошибку и можем пользоваться отладчиком как обычно:
![[Pasted image 20250925013733.png]]
