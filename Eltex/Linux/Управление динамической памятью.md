Использованные материалы:
- [[Препроцессор#` include`|include]]
- [[Функции]]
- [[Study/Eltex/C/Указатели]]
- [[Study/Eltex/Linux/Valgrind]]

**Динамическая память** - память, которая выделяется в момент выполнения программы. 
В любой момент выполнения её можно высвободить.

В Linux 32 bit идёт следующее распределение памяти:
![[Pasted image 20250922234719.png|300]]
Kernel space(1GB) - пространство с привилегированным кодом
User Mode Space(3GB) - пространство с непривилегированным кодом 

У каждой программы создается одинаковая копия виртуального пространства. 
Пример:
![[Pasted image 20250922235452.png|600]]
Белое - свободная память, Синее - занятая.
Здесь видно, что у каждой программы выделяется 1 GB под ядро, а остальное уходит программам. 

**Схема виртуальной памяти:**

![[Снимок экрана 2025-09-23 в 00.04.01.png|600]]
## Динамические библиотеки
Между стеком и кучей есть сегмент memory mapping, который хранит динамические библиотеки.

Если несколько программ используют одну **динамическую** библиотеку, во всех их виртуальных пространствах будет отображение на одну и ту же физическую страницу, где лежит эта библиотека.

# Динамическая память
Динамическая память хранится в куче или в сегменте memory mapping(только в случае, если был запрошен сегмент больше 128 КБ).
Но ссылки, которые указывают на память, будут располагаться в стеке.

## Низкоуровневые функции
Функции в C, которые напрямую взаимодействуют с кучей(сейчас не доступны из соображений безопасности):
```c
#include <unistd.h>

int brk(void *addr); // указывает адрес границы кучи

void *sbrk(intptr_t increment); // смещает адрес кучи на определенное значение в байтах
```
По сути они являются системными вызовами.

**Проверка, выделилась ли память:**
```c
#include <unistd.h>
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>

int main(void)
{
	char *ptr1;
	
	ptr1 = sbrk(100); // сдвинул границу на 100 байт
	if(ptr1 < 0) {
		perror("Out of memory!\n"); // заменяет код ошибки на текст
		exit(EXIT_FAILURE);
	}
	...
	return 0;
}
```
sbrk возвращает указатель на границу кучи. Адрес на него не может быть меньше 0, т.к. виртуальная память всегда начинается с 0. 
Если адрес меньше 0, выводим ошибку и завершаем программу.
## Библиотечные функции (malloc)
Реализация этой функции есть в нескольких библиотеках: `stdlib.h` и `malloc.h`.
**Версия в stdlib.h старая и не потокобезопасная!!!**
**Всегда нужно использовать версию из malloc.h**

### Описание функций
```c
#include <malloc.h>
#include <stdlib.h>
#include <alloca.h>

void *malloc (size_t size);
void *calloc (size_t nmemb, size_t size);
void free (void *ptr);
void *realloc (void *ptr, size_t size);

void alloca (size_t size);

// функции, нужные для статистики
void malloc_stats(void);
struct mallinfo mallinfo(void);
void malloc_trim(size_t pad);
int mallopt(int param, int value);
```

- `malloc` выделяет n байт. 
  Чтобы выделить память под несколько переменных, нужно указать "количество переменных * размер одной переменной". 
  При выделении память не инициализуруется(не зануляется)
- `calloc` - версия `malloc` с инициализацией. 
  Принимает два параметра: количество переменных(nmemb), размер одной переменной(size).
  Зануление памяти вручную значительно медленнее, чем `calloc`. Он очень эффективен.
- `free` очищает память. 
  Принимает указатель, который передался функциями `malloc`,`calloc`. ^d9f148
- `realloc` переопределяет размер выделенной ранее памяти.
  Принимает указатель от `malloc`, `calloc`, а также новый размер.
  Он намного эффективнее ручного переопределения памяти, т.к. проверяет все возможные варианты и выбирает лучший.
  Условно если есть свободное место над областью, которая будет переопределяться, он просто займёт её вместо сдвига всего массива в новую область. ^f4788a
- `alloca` выделяет динамическую память в стеке.
  Эту функцию не стоит использовать, т.к. стек имеет значительно бОльшие ограничения по памяти, чем куча.
  Он нужен, чтобы можно было не париться по поводу освобождения памяти для маленьких массивов.
### Чанк
Выделяемая память с помощью malloc итд. выглядит вот так:
![[Pasted image 20250923013505.png|300]]
- Heap - выделенные n байт
- cur_size - размер текущего блока.
  Этих полей два, т.к. в следующем блоке верхнее поле cur_size будет полем prev_size. То есть они будут пересекаться по этому(верхнему для одного и нижнего для другого) полю.
- prev_size - размер предыдущего блока

Функция [[#^d9f148|free]], считывая значение cur_size, понимает, сколько нужно высвободить.
Она преобразует память в такой вид:
![[Pasted image 20250923014404.png|300]]
Это двухсвязный список.
Далее функция [[#^f4788a|realloc]] ищет максимально похожий по размеру блок и использует его.
Если вызвать на подобный блок функцию [[#^d9f148|free]], возникнет ошибка segmentation fault.

# Утечка памяти
Допустим мы выделили 10 байт памяти. Затем, через условно 1000 строк кода решили выделить 20 байт памяти. В конце выполнения программы решаем освободить выделенное.
```c
char *ptr; 

ptr = malloc(10);
...
ptr = malloc(20);
...
free(ptr); // освободили malloc(20);
free(ptr); // ошибка segfault, т.к. адрес был затёрт прошлым free
```
В таком случае происходит утечка памяти, т.к. мы никак не можем освободить первые 10 байт. 
Единственный способ освободить память при утечке - остановить программу.
Для обнаружения утечек памяти можно использовать [[valgrind]].
