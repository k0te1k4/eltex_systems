Используемые материалы:
- [[Функции]]

**Препроцессор работает на этапе компиляции!!!**

# Директивы

## `#include`
`#include <stdio.h> или "header.h"` - присоединяет **заголовочный** файл с прототипами функций.
	Если используются `<угловые скобки>`, компилятор будет искать в системных путях.
	Если используются `"кавычки"`, компилятор будет искать в текущей папке.
Не стоит подключать .c файлы с его помощью, т.к. после компиляции получится огромный бинарник со всем кодом, независимо от разбиения файлов.

## `#define/#undef`
```c
#define TEST // TEST = 1
#undef TEST // TEST = 0

#define N 5 // все вхождения N заменятся на 5

#define max(a,b) ((a > b) ? a : b)


max(c,15) -> ((c > 15) ? c : 15) // пример
```

Заменяет ключ(первый параметр) на значение(второй параметр) во всём файле. 
Если значение не определено, будет использовано стандартное (1)
Замена происходит на этапе компиляции.

Если прописать команду `#undef key`, всё, что находится **ниже** этой директивы не будет заменено.

Также возможно писать строки по типу `max(func1(),func2())`. Они будут преобразованы в `((func1() > func2()) ? func1() : func2())`. Это неэффективно, поскольку каждая функция будет вызываться дважды(в этом примере).

## `#if/#else/#endif`
```c
#define A 5
...
#if A==5
...
#else [elif]
...
#endif
```
Используется только для проверки макроопределений([[#` define/ undef`]]). Подставлять в if переменные нельзя! Поскольку их значения будут неизвестны до запуска, а if/else будут обрабатываться до запуска.

Если значение истинно, в исходный код программы попадёт часть, написанная между if и else или endif, если else нет. С else ситуация аналогична. Он не выполняет какие-либо операции, просто подставляет текст, написанный в этих полях.

## `#ifdef/#ifndef`
```c
#define N
...
#ifdef N
...
#endif
```
```c
#define N
...
#ifndef N
...
#endif
```

Похожа на [[#` if/ else/ endif`|if/else/endif]], но проверяет не значение макроопределения, а было ли оно определено.

Это удобно, если пишется переносимый код, например на arm и x86 архитектуре. У них разные макроопределения. Соответственно можно запускать определенные архитектурно зависимые части кода.

### Пример
**EPOLL**
```c
#define EPOLL
...
#ifdef EPOLL
epoll_wait(...);

#elif POLL
poll(...);

#else
select(...);
#endif
```

**Заголовочные файлы (защита от множественных определений)**
my.h
```c
#ifndef _MY_H_
#define _MY_H_
...
struct test {};
#endif
```
my2.h
```c
#include "my.h"
...
```
test.c
```c
#include "my.h"
#include "my2.h"
...
```

Например если в файле my.h не будет проверки, а будет просто написана структура test:
1. my2.h подключает my.h, в нём теперь есть структура test. Теперь в файле my2.h есть структура test и ещё какой-то свой код.
2. test.c подключает my.h. всё, что в нём есть, импортируется в test.c. Затем подключает my2.h и импортирует все, что есть в нём. Получается двойное определение структуры test => ошибка multiple declaration.
Поэтому в my.h можно добавить проверку, не было ли ранее задано `_MY_H_`. 
Если оно уже было задано, игнорируем структуру test => ошибка устранена.

# Предопределенные константы
- `__LINE__` - подменяется на номер строки, в котором она указана
- `__FILE__` - имя файла, в котором она находится
- `__FUNCTION__` (сейчас называется `__func__`) - текущая функция
- `__DATE__` - текущая дата **на момент компиляции**
- `__TIME__` - текущее время **на момент компиляции**

```c
printf("LINE=%d FUNCTION=%S FILE=%s DATE=%S TIME=%s\n",__LINE__,__FUNCTION__,__FILE__,__DATE__,__TIME__);
```

