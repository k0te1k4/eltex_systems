Использованные материалы:
- [[Study/Eltex/C/Указатели]]
# Базовые определения
Не стоит писать функции с парой строк внутри, так как вызов функции использует ~300 машинных инструкций, со стороны оптимизации выгоднее написать несколько повторений маленького куска, или использовать **inline**.
 
**Объявление функции** - описание типа, параметров и тела функции:
 ```c
 int add(int param1, int param2)
 {
	 int ret;
	 ret = param1 + param2;
	 return ret;
 }
```
 
**Прототип функции** - объявление функции по типу `int func(int,int);`
 Он нужен для того, чтобы можно было вызывать функцию в коде **до** написания её тела.
 Для описания прототипов функций используется заголовочный файл.

**Заголовочный файл** - файл, в котором описываются все прототипы функций.

## Важно!
Все параметры, передаваемые в функцию, **копируются**, а не перемещаются. Соответственно если передать в функцию переменную, а затем изменить её внутри функции, в остальной программе переменная будет неизменна.
Пример:
```c
int func(int param1,int param2)
{
	param1 = 100;
	param2 = 200;
	int out = param1+param2;
	return out;
}
int a = 5;
int b = 10;
int c = func(a,b); // c = 300, a = 5, b = 10
```
## API/ABI
**API** (**A**pplication **p**rogramming **i**nterface) - программный интерфейс приложения. Описывает протокол взаимодействия между программами. Представляет из себя набор классов, библиотек, структур или констант

**ABI** (**A**pplication **b**inary **i**nterface) - двоичный интерфейс приложения. Описывает как программа работает с другими модулями ОС и с самой ОС
**ABI** регламентирует:
- использование регистров процессора
-  состав и формат системных вызовов и вызовов одного модуля другим
-  соглашение о вызове функции:
	- способ передачи аргументов в функцию (слева-направо или справа-налево)
	- порядок размещения аргументов в регистрах и/или стеке
	- код, ответственный за очистку стека.
	- конкретные инструкции, используемые для вызова и возврата.
	- код, ответственный за сохранение и восстановление содержимого регистров до и после вызова функции.
	- список регистров, подлежащих сохранению/восстановлению до/после вызова функции.
## Соглашение о вызове функции
Аргументы функций передаются через стек справа налево
Перед вызовом функции вставляется **пролог**:
- сохранение значений регистров, используемых внутри функции
- запись в стек аргументов функции
После вызова функции вставляется **эпилог**:
- восстановление значений регистров, сохраненных кодом пролога
- очистка стека от локальных переменных функции

# Кадр функции
Хранится в стеке
![[Pasted image 20250914215523.png|500]]
	`rbp`, `rsp` - 64 разрядные
	`rbp` - base pointer
	`rsp` - stack pointer
## Сохраненный rbp
**Сохраненный rbp** - хранит значение **rbp** функции, которая вызвала нас (родительской функции)
Если посчитать разницу между **rbp** и **rsp** можно найти размер области локальных переменных
## Локальные переменные
Внутри системы обращение к переменным идёт именно по сдвигу на n байт от регистра **rbp**.
Именно поэтому важно, чтобы **rbp** родительской функции сохранялся, иначе не получится обратиться к локальным переменным.
Память под локальные переменные выделяется также просто с помощью сдвига относительно **rbp**. 

Соответственно память под них не зануляется, поэтому если её не занулить вручную, внутри переменной будет мусор. 
Если нам нужно освободить память, просто прибавляем к **rsp**(не rbp, важно!!!) n байт, также не зануляя область.
## Аргументы функции
Также чтобы прочитать **аргументы функции** нужно от значения регистра **rbp** перепрыгнуть вперёд на 8 байт **сохраненного rbp**, потом на 8 байт **адреса возврата**.

## Завершение функции
При освобождении памяти происходит сдвиг регистра **rsp** в самый верх кадра без зануления памяти.

## Пример

```c
int func(int param1)
{
	int a;
	...
	return a;
}

int main(void)
{
	int b;
	...
	func(b);
	c = b;
	...
	return 0;
}
```

1. Начало. Вызвали функцию main.
	![[Pasted image 20250914222330.png|300]]
	- **Аргументы функции** - 0, т.к. никаких аргументов не передавали
	- **Адрес возврата** - возврат в функцию из библиотеки glibc
	- **Сохраненный rbp** - устанавливается значение **rbp**, которое было в функции из glibc. Регистр **rbp** ставится на начало этой области
	- **Локальные переменные** - выделилась область под две локальные переменные b и c. Регистр **rsp** ставится на начало этой области
2. Вызов функции func
	![[Pasted image 20250914223046.png|300]]
	- **Аргументы функции** - param1
	- **Адрес возврата** - адрес строки `c = b;` из кода примера
	- **Сохраненный rbp** - устанавливается значение регистра **rbp**, которое было в функции `main` (1000). Регистр **rbp** ставится на начало этой области
	- **Локальные переменные** - выделилась область под переменную a. Регистр **rsp** ставится на начало этой области
3. Завершение функции func, возврат в main
	![[Pasted image 20250914222330.png|300]]
	1. **rbp** прыгнул по адресу сохраненного **rbp** из предыдущего шага
	2. **rsp** прыгнул по адресу **rbp + размер локальных переменных**
	3. Программа выполняется дальше, обратившись по адресу возврата
	Область памяти, которая раньше была выделена под функцию func осталась на том же месте, просто теперь к ней ничего не обращается
# Работа с [[Study/Eltex/C/Указатели|указателями]]
Указатели используются для передачи адреса на объект внутрь функции, а также решения проблем с невозможностью вернуть типы, которые нельзя напрямую присвоить(структуры, массивы, строки).
```c
int add(int param1, int param2,int *param3)
{
	*param3 = param1 + param2;
	return 0;
}
...
int sum = 0;
...
add(5,6,&sum);
...
```
Вместо указателя на int может быть любой другой тип: массив, структура,...

## Изменение внешних переменных внутри функции
Также в случае с передачей адреса, как параметра, функция изменит исходный объект.
Пример:
```c
int func(int *param1,int *param2)
{
	*param1 = 100;
	*param2 = 200;
	int out = *param1 + *param2;
	return out;
}

int main()
{
int a = 5;
int b = 10;
int c = func(&a,&b); // c = 300, a = 100, b = 200
}
```
**Чтобы изменить исходный объект(любого типа, в том числе типа "указатель") мне нужно передать указатель на него.** То есть в случае, если я хочу изменить (одинарный, двойной, тройной...) указатель, мне нужно будет работать с указателем на (одинарный, двойной, тройной...) указатель.

# Функция с переменным количеством параметров
Первый параметр **всегда** должен иметь тип, чтобы через него можно было понять, какие будут следующие типы. Например в функции printf это сделано через `%буква`
Для работы с переменным количеством параметров используется библиотека `stdarg.h`
```c
#include <stdarg.h>
...
int my_print(char *format, ...)
{
	va_list args;
	va_start(args, format);
	...
	var = va_arg(args, int);
	...
	va_end(args);
	return 0;
}
...
```

