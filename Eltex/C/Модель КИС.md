Используемые материалы:
- [[Функции]]
- [[Препроцессор#Директивы|Директивы препроцессора]]
# Модульность
Раздельная компиляция - дробим код на несколько модулей, разделенных по файлам
Нужно компоновать функции по файлам так, чтобы потом было легко найти нужную функцию, то есть файлы - группы функций по определенному признаку(например функции, отвечающие за графику или ввод-вывод пользователя).

# Модель, контроллер, вьювер
Пример: программа-калькулятор

**Модель** - основные функции (в случае с калькулятором, операции вычисления)
**Вьювер** - то, как выглядит калькулятор(функции графики)
**Контроллер** - модуль, который обеспечивает взаимодействие модели и вьювера. (при нажатии на кнопку сложения вызывается функция сложения)

Например представим программу калькулятор и разобьем на модули:
1. Модуль счёта
	1. Вычитание
	2. Сложение
	3. Умножение
	4. Итд
2. Модуль ввода данных от пользователя
	1. Функции проверки ввода итд
3. Модуль графики
	1. Функции, отвечающие за графику
При разбиении на модули мы можем условно изменить графику, сделать его консольным или 3D, но все остальные функции не придется изменять.

# Модель КИС
Модель клиент, интерфейс, сервер.
Для начала нужно разбить программу на части, которые будут называться клиент и сервер

**Клиент** - часть программы, которая использует функционал сервера/сервиса
**Сервер** - функции, которые предоставляют услуги для клиента
**Интерфейс** - заголовочные файл с прототипом функций.
## Пример
1. Начальное состояние, все функции в одном файле
```c
// main.c
int main(void)
{
	long a,b,c,d,e,f,g,h,i,j;
	a = 5;
	b = 6;
	c = 7;
	d = 8;
	e = 9;
	f = 10;
	g = 11;
	h = 12;
	i = 13;
	
	printf("main=%p test=%p\n", main, test);
	j = test(a,b,c,d,e,f,g,h,i);
	return 0;
}

long test(long a, long b,long c,long d,long e,long f,long g,long h,long i)
{
	long sum = 0;
	sum = a+b+c+d+e+f+g+h+i;
	return sum;
}
```
Функция main вызывает(использует) функцию test.
Соответственно main - клиент, test - сервис.

2. Создадим отдельный файл для сервиса test:
```c
// test.c
long test(long a, long b,long c,long d,long e,long f,long g,long h,long i)
{
	long sum = 0;
	sum = a+b+c+d+e+f+g+h+i;
	return sum;
}
```
Но просто вынести test в отдельный файл не выйдет, main не увидит её. 
Нужно создать и подключить прототип функции test.

3. Создадим прототип функции test:
```c
// test.h
#ifndef __TEST_H__
#define __TEST_H__

long test(long,long,long,long,long,long,long,long,long);
#endif
//end of test.h
```
Для правильной работы файла используются [[Препроцессор#` ifdef/ ifndef`|директивы препроцессора ifndef/define/endif]].

4. Подключаем прототип test.h в main.c
```c
// main.c
#include "test.h" // <-- добавляем эту строку

int main(void)
{
	long a,b,c,d,e,f,g,h,i,j;
	a = 5;
	b = 6;
	c = 7;
	d = 8;
	e = 9;
	f = 10;
	g = 11;
	h = 12;
	i = 13;
	
	printf("main=%p test=%p\n", main, test);
	j = test(a,b,c,d,e,f,g,h,i);
	return 0;
}
```
Подключение происходит при помощи [[Препроцессор#` include`|директивы include]].
